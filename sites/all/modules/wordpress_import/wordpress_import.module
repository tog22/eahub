<?php

/**
 * @file
 * Wordpress module
 *
 * This module allow to import a blog form a WXR file generated by Worpdress
 */

/*
  Wordpress Import Drupal module : Import a Wordpress WXR file into Drupal
  Copyright (C) 2007 Yann Rocq <yann@rocq.net> - http://www.rocq.net/yann/

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License along
  with this program; if not, write to the Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */

/**
 * Implementation of hook_help()
 */
function wordpress_import_help($path, $arg) {
  $output = '';

  switch ($path) {
    case "admin/help#wordpress_import":
    $output = '<p>'.  t("This module imports a WXR file generated by Wordpress blog software into Drupal") .'</p>';
    break;
  }

  return $output;
}


/**
 * Implementation of hook_menu()
 */
function wordpress_import_menu() {
  $items = array();

  $items['admin/content/wordpress_import'] = array(
    'title' => 'Wordpress import',
    'description' => 'Import Wordpress WXR file',
    'page callback' => 'wordpress_import_home',
    'access arguments' => array('import wordpress blog'),
    );

  return $items;
}


/**
 * hook_perm
 *
 * @return array perms
 * @author Yann Rocq
 **/
function wordpress_import_perm() {
  return array('import wordpress blog');
}

/**
 * Module entry point
 */
function wordpress_import_home() {

  // XMLReader is required
  if (!extension_loaded('xmlreader')) {
    drupal_set_message(t('<strong>XMLReader PHP extension not found!</strong>  The XMLReader extension is available in PECL as of PHP 5.0.0 and is included and enabled as of PHP 5.1.0 by default. It can be enabled by adding the argument --enable-xmlreader  (or --with-xmlreader before 5.1.0) to your configure line. The libxml  extension is required. '), 'error');
    return '';
  }

  return wordpress_import_wizard();
}

/**
 * Create and manage the multistep form
 */
function wordpress_import_wizard() {
  $step = arg(3);

  ctools_include('wizard');
  ctools_include('object-cache');

  // *** SETUP ARRAY multistep setup ****
  $form_info = array(
    'id' => 'wordpress_import',
    'path' => "admin/content/wordpress_import/%step",
    'show trail' => FALSE,
    'show back' => FALSE,
    'show cancel' => TRUE,
    'show return' => FALSE,
    'next text' => t('Next'),
    'next callback' =>  'wordpress_import_form_subtask_next',
    'finish callback' => 'wordpress_import_form_subtask_finish',
    'return callback' => 'wordpress_import_form_subtask_finish',
    'cancel callback' => 'wordpress_import_form_subtask_cancel',
   // this controls order, as well as form labels
    'order' => array(
      'file' => t('Source file'),
      'options' => t('Options'),
      'og' => t('Organic groups'),
      'mapusers' => t('Map users'),
      'newusers' => t('New users'),
      'ready' => t('Ready'),
    ),
   // here we map a step to a form id.
    'forms' => array(
      'file' => array(
        'form id' => 'wordpress_import_form_file'
      ),
      'options' => array(
        'form id' => 'wordpress_import_form_options'
      ),
      'og' => array(
        'form id' => 'wordpress_import_form_og'
      ),
      'mapusers' => array(
        'form id' => 'wordpress_import_form_mapusers'
      ),
      'newusers' => array(
        'form id' => 'wordpress_import_form_newusers'
      ),
      'ready' => array(
        'form id' => 'wordpress_import_form_ready'
      ),
    ),
  );

  // *** SETTING THE FORM UP FOR MULTISTEP *** //
  $form_state = array(
    'cache name' => NULL,
  );

  $wordpress_import = wordpress_import_form_get_page_cache(NULL);

  if (!$wordpress_import && $step != '') {
    drupal_goto('admin/content/wordpress_import');
    return;
  }

  if (!$wordpress_import) {
    drupal_set_message($step);
    $step = current(array_keys($form_info['order']));
    $wordpress_import = new stdClass();
    ctools_object_cache_set('wordpress_import', $form_state['cache name'], $wordpress_import);
  }

  $form_state['wordpress_import_obj'] = $wordpress_import;

  // Skip OG step if module isn't present, or if node content type isn't an OG-enabled
  if ($step == 'og' && (!module_exists('og') || !($wordpress_import->options['nodetype_post_og'] || $wordpress_import->options['nodetype_page_og']))) {
    drupal_goto('admin/content/wordpress_import/mapusers');
  }

  // Skip users creation step if no new users
  if ($step == 'newusers' && !array_search('newuser', $wordpress_import->usermap)) {
    drupal_goto('admin/content/wordpress_import/ready');
  }

  $output = ctools_wizard_multistep_form($form_info, $step, $form_state);
  return $output;
}


/*---------------- CTools cache handling functions ------------ */

function wordpress_import_form_clear_page_cache($name) {
  ctools_object_cache_clear('wordpress_import', $name);
}


function wordpress_import_form_get_page_cache($name) {
  $cache = ctools_object_cache_get('wordpress_import', $name);
  return $cache;
}


/*-------------------------- Form Steps  ---------------------- */

function wordpress_import_form_file(&$form, &$form_state) {
  global $base_path;

  $wordpress_import = &$form_state['wordpress_import_obj'];

  $form['informations'] = array(
   '#value' => t('This module will import a Wordpress eXtended RSS (WXR) file generated by Wordpress. If you need instructions on creating this file, please read the  <a href="@codex">documentation</a>. <em>You must make a backup copy of your Drupal database before proceeding!</em>', array('@codex' => url('http://codex.wordpress.org/Tools_Export_SubPanel')))
  );

  // Upload file form element
  $form['upload'] = array(
    '#type' => 'file',
    '#title' => t('Upload your WXR file'),
    '#size' => 40,
    '#description' => t('The file can\'t exceed %maximum megabytes', array('%maximum' => $base_path . file_upload_max_size()/1024/1024)),
  );

  // Create and scan module directory
  $wordpress_import_path = file_create_path('wordpress');
  file_check_directory($wordpress_import_path, TRUE);
  $files = file_scan_directory($wordpress_import_path, '.*\.xml');

  if (count($files) > 0) {
    foreach (file_scan_directory($wordpress_import_path, '.*\.xml') as $file) {
      $options[$file->basename] = $file->basename;
    }
    ksort($options);
    $description = '';
  }
  else {
    $options = array();
    $description = t('No files found in %directory', array('%directory' => file_create_path(file_directory_path() .'/wordpress')));
  }

  // Local file selector element
  $form['local'] = array(
      '#title' => t('Or, alternatively, select a local WXR file'),
      '#type' => 'radios',
      '#description' => $description,
      '#options' => $options
    );

  $form['#attributes'] = array('enctype' => "multipart/form-data");

  $form_state['no buttons'] = TRUE;
}


function wordpress_import_form_file_validate(&$form, &$form_state) {

  if ($form_state['clicked_button']['#wizard type'] == 'cancel') {
    return;
  }

  // Process uploaded file (if any), and set file path
  $upload = file_save_upload('upload');
  if ($upload) {
    $form_state['values']['upload'] = $upload->filename;
    $filepath = $upload->filepath;
  }
  else {
    $filepath = file_directory_path() . '/wordpress/' . $form_state['values']['local'];
  }

  // Make sure a file was uploaded or a local file was selected
  if (empty($form_state['values']['upload']) && empty($form_state['values']['local'])) {
    form_set_error('upload', t('You must specify a WXR file to upload or select a local WXR file. If you attempted to upload a file, the operation may have failed.'));
    return;
  }
  else {
    $form_state['wordpress_import_obj']->filepath = $filepath;
  }

  if (!wordpress_import_read_wxr($form_state['wordpress_import_obj'])) {
    form_set_error('upload', t('<strong>This file does not appear to be a valid WXR file.</strong> The file is either corrupted or invalid XML. In some versions of WordPress, the export function can produce malformed XML. Please see README.txt (included in the module archive) for further guidance.'));
  }

}


function wordpress_import_form_file_submit(&$form, &$form_state) {
  (!empty($form_state['values']['upload'])) ? ($filesource = t('uploaded')) : ($filesource = t('local'));
  $fileinfo = pathinfo($form_state['wordpress_import_obj']->filepath);

  drupal_set_message(t('Successfully loaded @filesource file "@filename".', array('@filesource' => $filesource, '@filename' => $fileinfo['basename'])));

  $message = t('The following elements were identified :');

  $msg_found = array();
  $msg_found[] = '<li>' . t('@found_posts posts/pages', array('@found_posts' => $form_state['wordpress_import_obj']->count['posts'])) . '</li>';
  $msg_found[] = '<li>' . t('@found_comments comments', array('@found_comments' => $form_state['wordpress_import_obj']->count['comments'])) . '</li>';
  $msg_found[] = '<li>' . t('@found_authors authors', array('@found_authors' => count($form_state['wordpress_import_obj']->count['author_posts']))) . '</li>';
  $msg_found[] = '<li>' . t('@found_categories categories', array('@found_categories' => $form_state['wordpress_import_obj']->count['categories'])) . '</li>';
  $msg_found[] = '<li>' . t('@found_tags tags', array('@found_tags' => $form_state['wordpress_import_obj']->count['tags'])) . '</li>';

  drupal_set_message($message . '<ul>' . join("\n", $msg_found) . '</ul>');

  if (function_exists('dpm')) {
    dpm($form_state['wordpress_import_obj']->data);
  }
}


function wordpress_import_form_options(&$form, &$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];

  $form['basic_options'] = array(
    '#type' => 'fieldset',
    '#title' => t('Options'),
    '#collapsible' => FALSE,
    '#tree' => TRUE
  );

  // Post content type
  $node_types = node_get_types();
  $content_types = array('' => '', 'noimport' => t('Don\'t import'));
  foreach ($node_types as $k => $v) {
      if (!module_exists('og') || (module_exists('og') && !og_is_group_type($k))) {
        $content_types[$k] = $v->name;
      }
  }
  $form['basic_options']['nodetype_post'] = array(
    '#type' => 'select',
    '#title' => t('Import posts in content type'),
    '#description' => t('All imported posts will be assigned the selected content type. If you are unsure, select "Story"'),
    '#default_value' => '',
    '#options' => $content_types,
    );
  $form['basic_options']['nodetype_page'] = array(
    '#type' => 'select',
    '#title' => t('Import pages in content type'),
    '#description' => t('All imported pages will be assigned the selected content type. If you are unsure, select "Page"'),
    '#default_value' => '',
    '#options' => $content_types,
    );

  if (module_exists('locale')) {
    $default = language_default();
    $form['basic_options']['language'] = array(
      '#type' => 'select',
      '#title' => t('Language'),
      '#default_value' => $default->language,
      '#options' => array('' => t('Language neutral')) + locale_language_list('name'),
    );
  }

  $form['basic_options']['usermap_type'] = array(
      '#title' => t('User mapping'),
      '#type' => 'radios',
      '#description' => t('<strong>Single user</strong> will import all posts as one specified Drupal user. <strong>Manual</strong> permits the mapping of an existing or new Drupal user to each Wordpress author.'),
      '#options' => array(
        'default' => t('Single user'),
        'manual' => t('Manual'))
    );

  $form['advanced_options'] = array(
    '#type' => 'fieldset',
    '#title' => t('Advanced options'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#tree' => TRUE
  );

  $form['advanced_options']['disable_categories'] = array(
    '#type' => 'checkbox',
    '#title' => t('Don\'t import categories and tags'),
    '#default_value' => FALSE,
    '#disabled' => FALSE,
    '#description' => t('Check this box to disable import of categories and tags')
  );

  $form['advanced_options']['disable_comments'] = array(
    '#type' => 'checkbox',
    '#title' => t('Don\'t import comments'),
    '#default_value' => FALSE,
    '#disabled' => FALSE,
    '#description' => t('Check this box to disable import of comments')
  );

  $form['advanced_options']['disable_trackbacks'] = array(
    '#type' => 'checkbox',
    '#title' => t('Don\'t import trackbacks'),
    '#default_value' => FALSE,
    '#disabled' => FALSE,
    '#description' => t('Check this box to disable import of trackbacks')
  );

  $form['advanced_options']['aliases'] = array(
    '#type' => 'checkbox',
    '#title' => t('Create path aliases'),
    '#default_value' => FALSE,
    '#disabled' => FALSE,
    '#description' => t('Preserve the path of the original Wordpress posts and pages. For this to work properly, your Drupal site root must be the same as the Wordpress site (!root) and clean URLs should be activated', array('!root' => $wordpress_import->data['baseurl']))
  );

  $form['advanced_options']['images'] = array(
    '#type' => 'checkbox',
    '#title' => t('Transfer images'),
    '#default_value' => FALSE,
    '#description' => t('Try to download the images referenced in the blog posts locally')
  );

  $form['advanced_options']['images_dir'] = array(
    '#type' => 'textfield',
    '#title' => t('Images directory'),
    '#default_value' => '/images',
    '#description' => t('Subdirectory of <strong>@file_directory_path</strong> in which to place files, must start with /', array('@file_directory_path' => file_directory_path()))
  );

  // Warn if some key modules are not found
  if (!module_exists('taxonomy')) {
      drupal_set_message(t('Could not find module "path". <strong>Categories and tags will not be imported.</strong>'), 'error');
      $form['advanced_options']['disable_categories']['#default_value'] = TRUE;
      $form['advanced_options']['disable_categories']['#disabled'] = TRUE;
      $form['advanced_options']['#collapsed'] = FALSE;
  }
  if (!module_exists('comment')) {
      drupal_set_message(t('Could not find module "comment". <strong>Comments and tackbacks will not be imported.</strong>'), 'error');
      $form['advanced_options']['disable_comments']['#default_value'] = TRUE;
      $form['advanced_options']['disable_comments']['#disabled'] = TRUE;
      $form['advanced_options']['#collapsed'] = FALSE;
  }
  if (!module_exists('trackback')) {
      drupal_set_message(t('Could not find module "trackback". <strong>Trackbacks will not be imported.</strong>'), 'error');
      $form['advanced_options']['disable_trackbacks']['#default_value'] = TRUE;
      $form['advanced_options']['disable_trackbacks']['#disabled'] = TRUE;
      $form['advanced_options']['#collapsed'] = FALSE;
  }
  if (!module_exists('path')) {
      drupal_set_message(t('Could not find module "path". Create paths option disabled.'), 'warning');
      $form['advanced_options']['aliases']['#default_value'] = FALSE;
      $form['advanced_options']['aliases']['#disabled'] = TRUE;
  }
  if (!extension_loaded('curl')) {
      drupal_set_message(t('cURL PHP extension not available. Transfer images option disabled.'), 'warning');
      $form['advanced_options']['images']['#default_value'] = FALSE;
      $form['advanced_options']['images']['#disabled'] = TRUE;
  }
}


function wordpress_import_form_options_validate(&$form, &$form_state) {

  if ($form_state['clicked_button']['#wizard type'] == 'cancel') {
    return;
  }

  if (empty($form_state['values']['basic_options']['nodetype_post'])) {
    form_set_error('basic_options][nodetype', t('You must specify a content type to import Wordpress posts into.'));
  }

  if (empty($form_state['values']['basic_options']['nodetype_page'])) {
    form_set_error('basic_options][nodetype', t('You must specify a content type to import Wordpress pages into.'));
  }

  if (empty($form_state['values']['basic_options']['usermap_type'])) {
    form_set_error('basic_options][usermap_type', t('You must specify a user mapping method.'));
  }

  // Test if images directory is valid
  if ($form_state['values']['advanced_options']['images']) {
    $dir = file_directory_path() . rtrim($form_state['values']['advanced_options']['images_dir'], '/\\');
    if (!is_dir($dir)) {
      if (!@mkdir($dir)) {
        form_set_error('advanced_options][images_dir', t('Invalid images directory specified.'));
        $form['advanced_options']['#collapsed'] = FALSE;
      }
      else {
        @rmdir($dir);
      }
    }
  }
}


function wordpress_import_form_options_submit(&$form, &$form_state) {

  // Clear messages
  drupal_get_messages();

  $form_state['values']['advanced_options']['images_dir'] = file_directory_path() . rtrim($form_state['values']['advanced_options']['images_dir'], '/\\');

  $options = $form_state['values']['basic_options'] + $form_state['values']['advanced_options'];
  $form_state['wordpress_import_obj']->options = $options;

  // Verify if chosen content types are OG-enabled
  $form_state['wordpress_import_obj']->options['nodetype_post_og'] = FALSE;
  $form_state['wordpress_import_obj']->options['nodetype_page_og'] = FALSE;
  if (module_exists('og') && og_is_group_post_type($form_state['wordpress_import_obj']->options['nodetype_post'])) {
    $form_state['wordpress_import_obj']->options['nodetype_post_og'] = TRUE;
  }
  if (module_exists('og') && og_is_group_post_type($form_state['wordpress_import_obj']->options['nodetype_page'])) {
    $form_state['wordpress_import_obj']->options['nodetype_page_og'] = TRUE;
  }
}


function wordpress_import_form_og(&$form, &$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];

  $form['informations'] = array(
   '#value' => t('You selected a content type which is also an OG group post node type. You may select OG parameters for the imported content.')
  );

  $form['og_nodeapi'] = array(
    '#type' => 'fieldset',
    '#title' => t('Organic groups'),
    '#collapsible' => FALSE,
    '#tree' => TRUE,
  );
  og_form_add_og_audience($form, $form_state);

  if (module_exists('og_access')) {
    $form['og_nodeapi']['og_public'] = array(
    '#type' => 'checkbox',
    '#title' => 'Public',
    '#description' => t('Show this post to everyone, or only to members of the groups checked above. Posts without any groups are always <em>public</em>.'),
    );
  }
}


function wordpress_import_form_og_submit(&$form, &$form_state) {
  $form_state['wordpress_import_obj']->og_groups = $form_state['values']['og_nodeapi']['visible']['og_groups'];
  $form_state['wordpress_import_obj']->og_public = $form_state['values']['og_nodeapi']['og_public'];
}


function wordpress_import_form_mapusers(&$form, &$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];

  // Get Drupal users
  $sql = "SELECT * FROM {users} ORDER BY name ASC";
  $result =  db_query($sql);

  while ($drupal_user = db_fetch_array($result)) {
    if (!empty($drupal_user['uid'])) {
      $drupal_users[$drupal_user['uid']] = $drupal_user['name'];
    }
  }

  if ($wordpress_import->options['usermap_type'] == 'default') {

    $drupal_users = array('newuser' => t('Create new user')) + $drupal_users;

    $form['defaultuser'] = array(
      '#type' => 'select',
      '#title' => t('Default user'),
      '#description' => t('Map all Wordpress authors to one single Drupal user.'),
      '#options' => $drupal_users,
    );

  }
  else {

    $drupal_users = array('newuser' => t('Create new user'), 'noimport' => t('Do not import')) + $drupal_users;

    $form['usermap'] = array(
      '#title' => t('Users mapping'),
      '#type' => 'fieldset',
      '#description' => t('Map each Wordpress user to a distinct Drupal user. The number of posts for each Worpress user is indicated next to the usernames.'),
      '#collapsible' => FALSE,
      '#tree' => TRUE
    );

    foreach ($wordpress_import ->usermap as $wp_user => $drupal_user) {
      $form['usermap'][$wp_user] = array(
        '#type' => 'select',
        '#title' => $wp_user . ' (' . $wordpress_import->count['author_posts'][$wp_user] . ')',
        '#options' => $drupal_users,
      );
    }

  }
}


function wordpress_import_form_mapusers_validate(&$form, &$form_state) {

  if ($form_state['clicked_button']['#wizard type'] == 'cancel') {
    return;
  }

  // Make sure there is something to import
  if (count($form_state['values']['usermap']) > 0) {
    $i = FALSE;
    foreach ($form_state['values']['usermap'] as $wp_user => $drupal_user) {
      if ($drupal_user != 'noimport') {
        $i = TRUE;
        break;
      }
    }
    if (!$i) {
      form_set_error('usermap', t('Nothing to import!'));
    }
  }
  elseif (empty($form_state['values']['defaultuser'])) {
    form_set_error('defaultuser', t('Nothing to import!'));
  }
}


function wordpress_import_form_mapusers_submit(&$form, &$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];

  if ($wordpress_import->options['usermap_type'] == 'default') {
    foreach ($wordpress_import->usermap as $key => $value) {
      $wordpress_import->usermap[$key] = $form_state['values']['defaultuser'];
    }
  }
  else {
    $wordpress_import->usermap = $form_state['values']['usermap'];
  }
}


function wordpress_import_form_newusers(&$form, &$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];

  $form['newuser'] = array('#tree' => TRUE);

  if ($wordpress_import->options['usermap_type'] == 'default') {

    $form['newuser']['default'] = array('#type' => 'fieldset', '#title' => t('All Wordpress authors'));
    $form['newuser']['default']['name'] = array('#type' => 'textfield', '#title' => t('Username for new user'));
    $form['newuser']['default']['mail'] = array('#type' => 'textfield', '#title' => t('E-mail address for new user'));

  }
  else {

    foreach ($wordpress_import->usermap as $key => $value) {
      if ($value == 'newuser') {
        $form['newuser'][$key] = array('#type' => 'fieldset', '#title' => t('Wordpress author %user', array('%user' => $key)));
        $form['newuser'][$key]['name'] = array('#type' => 'textfield', '#title' => t('Username for Wordpress author %user', array('%user' => $key)), '#default_value' => $key);
        $form['newuser'][$key]['mail'] = array('#type' => 'textfield', '#title' => t('E-mail address for Wordpress author %user', array('%user' => $key)));
      }
    }

  }
}


function wordpress_import_form_newusers_validate(&$form, &$form_state) {
  global $user;

  if ($form_state['clicked_button']['#wizard type'] == 'cancel') {
    return;
  }

  foreach ($form_state['values']['newuser'] as $key => $value) {

    // Check usernames
    if ($error = user_validate_name($value['name'])) {
      form_set_error('newuser]['. $key .'][name', $error);
    }
    elseif (user_load(array('name' => $value['name']))) {
      form_set_error('newuser]['. $key .'][name', t('User !user already exists.', array('!user' => $value['name'])));
    }
    elseif (is_array($user['name']) && in_array(strtolower($value['name']), $user['name'])) {
      form_set_error('newuser]['. $key .'][name', t('Two users have the same name (!user).', array('!user' => $value['name'])));
    }

    // Check user emails
    if ($error = user_validate_mail($value['mail'])) {
      form_set_error('newuser]['. $key .'][mail', $error);
    }
    elseif (user_load(array('mail' => $value['mail']))) {
      form_set_error('newuser]['. $key .'][mail', t('User with mail !mail already exists.', array('!mail' => $value['mail'])));
    }
    elseif (is_array($user['mail']) && in_array(strtolower($value['mail']), $user['mail'])) {
      form_set_error('newuser]['. $key .'][mail', t('Two users have the same mail (!mail).', array('!mail' => $value['mail'])));
    }

    $user['name'][] = strtolower($value['name']);
    $user['mail'][] = strtolower($value['mail']);
  }
}


function wordpress_import_form_newusers_submit(&$form, &$form_state) {
  $form_state['wordpress_import_obj']->newuser = $form_state['values']['newuser'];
}


function wordpress_import_form_ready(&$form, &$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];
  
  if (function_exists('dpm')) {
    dpm($wordpress_import);
  }

  $form['informations'] = array(
   '#value' => t('Wordpress Import configuration is complete. Click "Finish" to launch the import process.'),
  );
}


/* ---------------- Form callback functions ---------------- */

function wordpress_import_form_subtask_next(&$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];
  $cache = ctools_object_cache_set('wordpress_import', $form_state['cache name'], $wordpress_import);
}


function wordpress_import_form_subtask_cancel(&$form_state) {
  ctools_object_cache_clear('wordpress_import', $form_state['cache name']);
  $form_state['redirect'] = 'admin/content/wordpress_import';
  drupal_get_messages();
  drupal_set_message('Import operation cancelled.');
}


function wordpress_import_form_subtask_finish(&$form_state) {
  $wordpress_import = &$form_state['wordpress_import_obj'];
  wordpress_import_form_clear_page_cache($form_state['cache name']);

  // Prepare images directory
  if ($wordpress_import->options['images'] && !empty($wordpress_import->options['images_dir'])) {
    file_check_directory($wordpress_import->options['images_dir'], TRUE);
  }

  // Prepare batch operations
  $operations = array();
  $operations[] = array('wordpress_import_process_blog', array($wordpress_import));

  // Set up batch process
  $batch = array(
    'operations' => $operations,
    'finished' => 'wordpress_import_batch_finished',
    'title' => t('Wordpress import'),
    'init_message' => t('Wordpress import is starting processing'),
    'progress_message' => t('Processed @current out of @total.'),
    'error_message' => t('Wordpress import has encountered an error.'),
  );

  batch_set($batch);
  batch_process();

}

/**
 * Main batch import function.
 */
function wordpress_import_process_blog($wordpress_import, &$context) {

  // Initialize sandbox and results arrays to keep track of important import info
  if (empty($context['sandbox'])) {
    $context['sandbox']['vocab_done'] = FALSE;
    $context['sandbox']['users_done'] = FALSE;
    $context['sandbox']['format_done'] = FALSE;
    $context['sandbox']['progress'] = 0;
    $context['results']['created_users'] = 0;
    $context['results']['created_nodes'] = 0;
    $context['results']['created_terms'] = 0;
    $context['results']['created_categories'] = 0;
    $context['results']['downloaded_images'] = array();
    $context['results']['error_images'] = array();
    $context['results']['password_protected'] = 0;
    $context['results']['created_comments'] = 0;
    $context['results']['created_trackbacks'] = 0;
  }

  // Create Drupal vocabularies for Wordpress categories and tags and populate them
  if (!$context['sandbox']['vocab_done'] && !$wordpress_import->options['disable_categories']) {
    wordpress_import_process_categories_tags($wordpress_import, $context);
    $context['sandbox']['vocab_done'] = TRUE;
  }

  // Create Drupal users as needed
  if (!$context['sandbox']['users_done']) {
      if ($wordpress_import->options['usermap_type'] == 'default' && !empty($wordpress_import->newuser['default'])) {

      // Create new default Drupal user and assign uid to each Wordpress author
      $defaultuser = array('mail' => $wordpress_import->newuser['default']['mail'], 'pass' => user_password(), 'name' => $wordpress_import->newuser['default']['name'], 'status' => 1);
      $defaultuser = user_save('', $defaultuser);
      $context['results']['created_users']++;

      foreach ($wordpress_import->usermap as $key => $value) {
        $wordpress_import->usermap[$key] = $defaultuser->uid;
      }

    }
    elseif ($wordpress_import->options['usermap_type'] == 'manual' && count($wordpress_import->newuser) > 0) {

      // Create new Drupal users as required and assign uid to corresponding Wordpress author
      foreach ($wordpress_import->newuser as $key => $value) {
        $user = array('mail' => $value['mail'], 'pass' => user_password(), 'name' => $value['name'], 'status' => 1);
        $user = user_save('', $user);
        $wordpress_import->usermap[$key] = $user->uid;
        $context['results']['created_users']++;
      }
    }
    $context['sandbox']['users_done'] = TRUE;
  }

  // Get or create content format as needed
  if (!$context['sandbox']['format_done']) {
    $wordpress_import->format = variable_get('wordpress_import_format_id', 0);
    if (!$wordpress_import->format || !filter_formats($wordpress_import->format)) {
      db_query("INSERT INTO {filter_formats} (name,cache) VALUES ('%s',1)", 'Wordpress format');
      $wordpress_import->format = db_result(db_query("SELECT MAX(format) AS format FROM {filter_formats}"));
      db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", $wordpress_import->format, 'filter', 2, 0);
      variable_set('wordpress_import_format_id', $wordpress_import->format);
    }
    $context['sandbox']['format_done'] = TRUE;
  }

  // Initialize XML stream-based parsing
  $wordpress_import->reader = new XMLReader();
  $wordpress_import->reader->open($wordpress_import->filepath);

  // Limit number of posts imported per batch run
  $limit = 10;

  // Skip already imported posts
  $skip_imported = $context['sandbox']['progress'];

  while ($limit > 0 && $context['sandbox']['progress'] < $wordpress_import->count['posts']) {
    while ($wordpress_import->reader->read()) {
      if ($wordpress_import->reader->name == 'item' && $wordpress_import->reader->nodeType == XMLReader::ELEMENT) {
        if ($skip_imported > 0) {
          $wordpress_import->reader->next();
          $skip_imported--;
        }
        else {
          wordpress_import_process_post($wordpress_import, $context);
          $context['sandbox']['progress']++;
          $limit--;
          break;
        }
      }
    }
  }

  if ($context['sandbox']['progress'] < $wordpress_import->count['posts']) {
    $context['finished'] = $context['sandbox']['progress'] / ($wordpress_import->count['posts'] - 1);
  }

  $wordpress_import->reader->close();
}

/**
 * Import categories and tags as taxonomy terms
 */
function wordpress_import_process_categories_tags(&$wordpress_import, &$context) {

  if (!empty($wordpress_import->data['categories'])) {

    $category_vocabulary_data = array(
      'name' => t('Wordpress category'),
      'module' => 'wordpress_import',
      'multiple' => 1,
      'nodes' => array($wordpress_import->options['nodetype'] => $wordpress_import->options['nodetype'])
    );

    $wordpress_import->categories_vocabulary = wordpress_import_create_vocabulary('category', $category_vocabulary_data);
    $wordpress_import->categories_map = wordpress_import_get_terms($wordpress_import->categories_vocabulary);

    foreach ($wordpress_import->data['categories'] as $category) {

      // Create term if it doesn't exist
      if (empty($wordpress_import->categories_map[$category['cat_name']])) {
        $term = array(
          'name' => $category['cat_name'],
          'description' => $category['category_description'],
          'vid' => $wordpress_import->categories_vocabulary,
          );

        if (!empty($category['category_parent']) && !empty($wordpress_import->categories_map[$category['category_parent']])) {
          $term['parent'] = $wordpress_import->categories_map[$category['category_parent']];
        }

        taxonomy_save_term($term);
        $wordpress_import->categories_map[$category['cat_name']] = $term['tid'];

        $context['results']['created_terms']++;
      }
    }
  }

  if (!empty($wordpress_import->data['tags'])) {

    $tag_vocabulary_data = array(
      'name' => t('Wordpress tag'),
      'module' => 'wordpress_import',
      'tags' => 1,
      'multiple' => 1,
      'nodes' => array($wordpress_import->options['nodetype'] => $wordpress_import->options['nodetype'])
    );

    $wordpress_import->tags_vocabulary = wordpress_import_create_vocabulary('tag', $tag_vocabulary_data);
    $wordpress_import->tags_map = wordpress_import_get_terms($wordpress_import->tags_vocabulary);

    foreach ($wordpress_import->data['tags'] as $tag => $description) {

      // Create term if it doesn't exist
      if (empty($wordpress_import->tags_map[$tag])) {
        $term = array(
          'name' => $tag,
          'description' => $description,
          'vid' => $wordpress_import->tags_vocabulary,
          );

        taxonomy_save_term($term);
        $wordpress_import->tags_map[$tag] = $term['tid'];

        $context['results']['created_terms']++;
      }
    }
  }
}

/**
 * Process a Wordpress post
 */
function wordpress_import_process_post(&$wordpress_import, &$context) {

  $reader = $wordpress_import->reader;
  $context['sandbox']['node_duplicate'] = FALSE;
  $context['sandbox']['post'] = array('categories' => array(), 'tags' => array(), 'comments' => array());
  $context['sandbox']['downloaded_images'] = array();
  $context['sandbox']['error_images'] = array();

  $post = & $context['sandbox']['post'];

  while ($reader->read() && !($reader->name == 'item' && $reader->nodeType == XMLReader::END_ELEMENT)) {
    if ($reader->nodeType == XMLReader::ELEMENT) {
      switch ($reader->name) {
        case 'title' :
          $reader->read();
          $post['title'] = $reader->value;
          break;
        case 'dc:creator' :
          $reader->read();
          $post['author'] = $reader->value;
          break;
        case 'wp:post_date' :
          $reader->read();
          $post['date'] = $reader->value;
          break;
        case 'wp:post_type' :
          $reader->read();
          $post['type'] = $reader->value;
          break;
        case 'wp:status' :
          $reader->read();
          $post['status'] = $reader->value;
          break;
        case 'wp:is_sticky' :
          $reader->read();
          $post['is_sticky'] = $reader->value;
          break;
        case 'wp:post_password' :
          $reader->read();
          $post['post_password'] = $reader->value;
          break;
        case 'content:encoded' :
          $reader->read();
          $post['content'] = $reader->value;
          break;
        case 'excerpt:encoded' :
          $reader->read();
          $post['excerpt'] = $reader->value;
          break;
        case 'link' :
          $reader->read();
          $post['link'] = $reader->value;
          break;
        case 'wp:comment_status' :
          $reader->read();
          $post['comment_status'] = $reader->value;
          break;
        case 'category' :
          if (!$wordpress_import->options['disable_categories']) {
            if ($reader->getAttribute('domain') == 'category') {
              $reader->read();
              $post['categories'][] = $reader->value;
            }
            elseif ($reader->getAttribute('domain') == 'tag') {
              $reader->read();
              $post['tags'][] = $reader->value;
            }
          }
          break;
        case 'wp:comment' :
          if (!$wordpress_import->options['disable_comments']) {
            $comment = array();
            while ($reader->read() && !($reader->name == 'wp:comment' && $reader->nodeType == XMLReader::END_ELEMENT)) {
              if ($reader->nodeType == XMLReader::ELEMENT) {
                $nodename = str_replace('wp:comment_', '', $reader->name);
                $reader->read();
                $comment[$nodename] = $reader->value;
              }
            }
            if (!empty($comment)) {
              $post['comments'][] = $comment;
            }
          }
          break;
      }
    }
  }

  // Node object setup ---------------------- //
  $node = array();
  $node_og = FALSE;

  // Node type
  switch ($post['type']) {
    case 'post' :
      $node['type'] = $wordpress_import->options['nodetype_post'];
      $node_og = $wordpress_import->options['nodetype_post_og'];
      break;
    case 'page' :
      $node['type'] = $wordpress_import->options['nodetype_page'];
      $node_og = $wordpress_import->options['nodetype_page_og'];
      break;
    default :
      return;
  }

  // Catch noimport content type flag
  if ($node['type'] == 'noimport') {
    return;
  }

  // Node uid (return if we don't want this author)
  $node['uid'] = $wordpress_import->usermap[$post['author']];
  if ($node['uid'] == 'noimport' || !ctype_digit($node['uid'])) {
    return;
  }

  // Node title
  if (!empty($post['title'])) {
    $node['title'] = html_entity_decode($post['title'], ENT_COMPAT, 'UTF-8');
  }
  else {
    $node['title'] = t('Untitled');
  }

  // Node content
  $node['body'] = str_replace('<!--more-->', '<!--break-->', $post['content']);

  // Node format
  $node['format'] = $wordpress_import->format;

  // Node teaser
  if (empty($post['excerpt'])) {
    $node['teaser'] = node_teaser($node['body'], $node['format']);
  }
  else {
    $node['teaser'] = $post['excerpt'];
  }

  // Node language
  $node['language'] = (isset($wordpress_import->options['language']) ? $wordpress_import->options['language'] : '');

  // Node timestamp
  $node['created'] = strtotime($post['date']);
  $node['changed'] = $node['created'];

  // Node status
  switch ($post['status']) {
    case 'publish':
      if (empty($post['post_password'])) {
        $node['status'] = 1;
      }
      else {
        $node['status'] = 0;
        $context['results']['password_protected']++;
      }
      break;
    default:
      $node['status'] = 0;
  }

  // Node promote
  switch ($post['is_sticky']) {
    case '1':
      $node['promote'] = 1;
      break;
    default:
      $node['promote'] = 0;
  }

  // Node comment status
  $node['comment'] = $post['comment_status']=='open'?COMMENT_NODE_READ_WRITE:COMMENT_NODE_READ_ONLY;

  // Check if node wasn't already imported
  $context['sandbox']['node_duplicate'] = node_load(array('created' => $node['created'], 'title' => $node['title'], 'type' => $node['type']));
  if ($context['sandbox']['node_duplicate']->nid) {
    if (module_exists('comment') && !empty($post['comments'])) {
      wordpress_import_process_post_comments($post['comments'], $context['sandbox']['node_duplicate']->nid, $wordpress_import->options['disable_trackbacks'], $context);
    }
    unset($context['sandbox']['node_duplicate']);
    unset($context['sandbox']['post']);
    return;
  }

  // Process link for this post
  if (module_exists('path') && $wordpress_import->options['aliases']) {
    $node['path'] = wordpress_import_process_post_link($post['link'], $wordpress_import->data['baseurl']);
    if (module_exists('pathauto')) {
      $node['pathauto_perform_alias'] = 0;
    }
  }

  // Process categories and tags for this post
  if (module_exists('taxonomy') && !(empty($post['categories']) && empty($post['tags']))) {
    $node['taxonomy'] = wordpress_import_process_post_categories_tags($post['categories'], $wordpress_import->categories_vocabulary, $wordpress_import->categories_map, $post['tags'], $wordpress_import->tags_vocabulary);
  }

  // Process images for this post
  if ($wordpress_import->options['images']) {
    wordpress_import_process_post_images($node['body'], $wordpress_import->options['images_dir'], $context);
  }

  // Save the node
  $node = (object)$node;
  node_save($node);

  // Process comments and trackbacks for this post
  if (module_exists('comment') && !empty($post['comments'])) {
    wordpress_import_process_post_comments($post['comments'], $node->nid, $wordpress_import->options['disable_trackbacks'], $context);
  }

  // Node OG parameters
  if (module_exists('og') && $node_og) {
    $node->og_groups = $wordpress_import->og_groups;
    $node->og_public = (int) $wordpress_import->og_public;
    og_save_ancestry($node);
  }

  // Update messages infos with nid
  if (!empty($context['sandbox']['downloaded_images']) || !empty($context['sandbox']['error_images'])) {
    foreach ($context['sandbox']['downloaded_images'] as $a) {
      $a['nid'] = $node->nid;
      $context['results']['downloaded_images'][] = $a;
    }
    foreach ($context['sandbox']['error_images'] as $a) {
      $a['nid'] = $node->nid;
      $a['title'] = $node->title;
      $context['results']['error_images'][] = $a;
    }
  }

  // Update the context
  $context['results']['created_nodes']++;
  $context['message'] = t('Import in progress : @created - @title', array('@created' => format_date($node->created, 'small'), '@title' => $node->title));

  unset($context['sandbox']['post']);
  unset($context['sandbox']['downloaded_images']);
  unset($context['sandbox']['error_images']);
}

/**
 * Process post link into node path
 */
function wordpress_import_process_post_link($link, $baseurl) {

  $path = $link;
  $path = substr($path, strlen($baseurl));
  $path = rtrim($path, '/');

  // Check for Wordpress ugly permalinks and replace with proper Drupal-style aliases
  if (preg_match('/\?p=(\d+)/', $path, $id)) {
    $path = 'p/' . $id[1];
  }
  elseif (preg_match('/\?page_id=(\d+)/', $path, $id)) {
    $path = 'page_id/' . $id[1];
  }

  return $path;
}

/**
 * Process post categories and tags and associate to taxonomy terms
 */
function wordpress_import_process_post_categories_tags($categories, $categories_vocabulary, $categories_map, $tags, $tags_vocabulary) {

  $taxonomy = array();
  $drupal_tags = array();

  // Remove duplicates
  $categories = array_unique($categories);
  $tags = array_unique($tags);

  // Process categories
  foreach ($categories as $category) {
    $term = $categories_map[$category];
    if (!empty($term)) {
        $taxonomy[$categories_vocabulary][] = $term;
    }
  }

  // Process tags
  if (!empty($tags)) {
    $taxonomy['tags'][$tags_vocabulary] = join(',', $tags);
  }

  return $taxonomy;

}

/**
 * Process comments and trackbacks for this post
 */
function wordpress_import_process_post_comments($comments, $nid, $disable_trackbacks, &$context) {

  $node_duplicate = $context['sandbox']['node_duplicate'];

  $node_trackbacks = array();
  $node_comments = array();
  $comment_id = 0;

  foreach ($comments as $comment) {

    switch ($comment['approved']) {
      case '0':
        $status = COMMENT_NOT_PUBLISHED;
        break;
      case '1':
        $status = COMMENT_PUBLISHED;
        break;
      case 'spam':
        continue 2;
    }

    switch ($comment['type']) {
      case 'trackback':
        if (module_exists('trackback') && !$disable_trackbacks) {
          $node_trackback = array(
            'nid' => $nid,
            'created' => strtotime($comment['date']),
            'site' => $comment['author_IP'],
            'name' => decode_entities(strip_tags($comment['author'])),
            'subject' => trim(truncate_utf8(decode_entities(strip_tags($comment['content'])), 29, TRUE)),
            'url' => $comment['author_url'],
            'excerpt' => $comment['content'],
            'status' => 1
            );
          // Check if duplicate
          if ($node_duplicate) {
            $tr = db_query("SELECT tr.trid FROM {trackback_received} tr WHERE tr.nid = %d AND tr.created = %d", $node_duplicate->nid, $node_trackback['created']);
            if ($tr->trid && $tr->excerpt == $node_trackback['excerpt']) {
              continue 2;
            }
            else {
              $node_trackbacks[$node_trackback['created']] = $node_trackback;
            }
          }
        }
        break;
      default:
        $node_comment = array(
          'nid' => $nid,
          'pid' => 0,
          'comment' => $comment['content'],
          'subject' => trim(truncate_utf8(decode_entities(strip_tags($comment['content'])), 29, TRUE)),
          'name' => decode_entities(strip_tags($comment['author'])),
          'mail' => $comment['author_email'],
          'homepage' => $comment['author_url'],
          'timestamp' => strtotime($comment['date']),
          'hostname' => $comment['author_IP'],
          'status' => $status,
          'format' => $wordpress_import->format
          );
        // Check if duplicate
        if ($node_duplicate) {
          $c = db_query("SELECT c.cid, c.comment FROM {comments} c WHERE c.nid = %d AND c.timestamp = %d", $node_duplicate->nid, $node_comment['timestamp']);
          if ($c->cid && $c->comment == $node_comment['comment']) {
            continue 2;
          }
        }
        else {
          $node_comments[$node_comment['timestamp']] = $node_comment;
        }
        break;
    }
  }

  // Sort comments by timestamp so the thread won't be messed up in Drupal
  ksort($node_trackbacks);
  ksort($node_comments);

  // Save trackbacks
  foreach ($node_trackbacks as $node_trackback) {
    db_query("INSERT INTO {trackback_received} (nid, created, site, name, subject, url, excerpt, status) VALUES (%d, %d, '%s', '%s', '%s', '%s', '%s', %d)",
      $node_trackback['nid'],
      $node_trackback['created'],
      $node_trackback['site'],
      $node_trackback['name'],
      $node_trackback['subject'],
      $node_trackback['url'],
      $node_trackback['excerpt'],
      $node_trackback['status']
      );
    $context['results']['created_trackbacks']++;
  }

  // Save comments
  foreach ($node_comments as $node_comment) {
    $comment_id = comment_save($node_comment);
    // Update fields that haven't been set by comment_save
    db_query("UPDATE {comments} SET hostname= '%s', timestamp= %d, status= %d WHERE cid= %d",
      $node_comment['hostname'],
      $node_comment['timestamp'],
      $node_comment['status'],
      $comment_id
      );
    $context['results']['created_comments']++;
  }
}

/**
 * Process node body and download image content
 */
function wordpress_import_process_post_images(&$body, $images_dir, $context) {
  global $base_path;

  // Find image URL in content
  preg_match_all('/(img|src)=("|\')[^"\'>]+/i', $body, $media);
  $imgdata = preg_replace('/(img|src)("|\'|="|=\')(.*)/i', "$3", $media[0]);

  foreach ($imgdata as $imgurl) {
    $urlinfo = parse_url($imgurl);
    $imginfo = pathinfo($urlinfo['path']);
    if (($urlinfo['scheme'] == 'http' || $urlinfo['scheme'] == 'https') && isset($imginfo['extension'])) {
      if ((strcasecmp($imginfo['extension'], 'jpg') == 0) ||
        (strcasecmp($imginfo['extension'], 'jpeg') == 0) ||
        (strcasecmp($imginfo['extension'], 'gif') == 0) ||
        (strcasecmp($imginfo['extension'], 'png') == 0)) {

        $ch = curl_init($imgurl);

        // Check if cURL object OK
        if (!$ch) {
          $context['sandbox']['error_images'][] = array('oldurl' => $imgurl);
          continue;
        }

        // Check if image was already downloaded
        foreach ($context['results']['downloaded_images'] as $img) {
          if ($img['imgurl'] == $imgurl) {
            $body = str_replace($imgurl, $img['newurl'], $body);
            continue 2;
          }
        }

        curl_setopt($ch, CURLOPT_TIMEOUT, 10);

        // Obtain new URL in case of redirections
        $imgnewurl = curl_redir_url($ch);
        curl_close($ch);

        if ($imgnewurl) {

          // Download image
          $imgfile = file_create_filename(urldecode($imginfo['basename']), $images_dir);
          $imgout = fopen($imgfile, 'wb');
          $ch = curl_init($imgnewurl);
          curl_setopt($ch, CURLOPT_HEADER, FALSE);
          curl_setopt($ch, CURLOPT_TIMEOUT, 10);
          curl_setopt($ch, CURLOPT_FILE, $imgout);
          curl_exec($ch);
          curl_close($ch);
          fclose($imgout);

          $newurl = $base_path . $images_dir . '/' . $imginfo['basename'];

          // Replace image URL with new path in post
          $body = str_replace($imgurl, $newurl, $body);
          $context['sandbox']['downloaded_images'][] = array('oldurl' => $imgurl, 'newurl' => $newurl, 'file' => $imgfile);
        }
        else {
          $context['sandbox']['error_images'][] = array('oldurl' => $imgurl);
        }
      }
    }
  }
}

/**
 * Batch wrap-up function, displays import process results
 */
function wordpress_import_batch_finished($success, $results, $operations) {

  if ($success) {

    $message = t('Import successful : ');

    $msg_results = array();
    $msg_results[] = '<li>' . t('@created_nodes nodes', array('@created_nodes' => $results['created_nodes'])) . '</li>';
    $msg_results[] = '<li>' . t('@created_users users', array('@created_users' => $results['created_users'])) . '</li>';
    $msg_results[] = '<li>' . t('@created_terms taxonomy terms', array('@created_terms' => $results['created_terms'])) . '</li>';
    $msg_results[] = '<li>' . t('@created_comments comments', array('@created_comments' => $results['created_comments'])) . '</li>';
    $msg_results[] = '<li>' . t('@created_trackbacks trackbacks', array('@created_trackbacks' => $results['created_trackbacks'])) . '</li>';
    $msg_results[] = '<li>' . t('@downloaded_images/@total_images images', array('@downloaded_images' => count($results['downloaded_images']), '@total_images' => count($results['downloaded_images'])+count($results['error_images']))) . '</li>';

    drupal_set_message($message . '<ul>' . join("\n", $msg_results) . '</ul>');
    
    if (function_exists('dpm')) {
      dpm($results['error_images']);
    }

    if (count($results['error_images']) > 0) {

      $errors = '';
      foreach ($results['error_images'] as $error_image) {
        $errors .= '<li>' . l($error_image['title'], 'node/' . $error_image['nid']) . "</li>\n";
      }
      drupal_set_message(t('Some images could not be transferred for these nodes :') . '<ul>' . $errors . '</ul>', 'warning');
    }
    
    if ($results['password_protected'] > 0) {
      drupal_set_message(t('Encountered @password_protected password-protected posts. These were imported as unpublished nodes.', array('@password_protected' => $results['password_protected'])), 'warning');
    }

  }
  else {

    drupal_set_message(t('Import failed.'), 'error');

  }

}


/* ---------------- Import utility functions ---------------- */

/**
 * Open WXR file in XMLReader and extract relevant data prior to import.
 */
function wordpress_import_read_wxr(&$wordpress_import) {

  $is_wxr_file = FALSE;
  $is_valid_xml = FALSE;

  $wordpress_import->data['categories'] = array();
  $wordpress_import->data['tags'] = array();
  $wordpress_import->usermap = array();
  $wordpress_import->count['posts'] = 0;
  $wordpress_import->count['author_posts'] = array();
  $wordpress_import->count['comments'] = 0;
  $wordpress_import->count['categories'] = 0;
  $wordpress_import->count['tags'] = 0;

  $reader = new XMLReader();
  $reader->open($wordpress_import->filepath);

  while ($reader->read()) {

    if ($reader->nodeType == XMLReader::ELEMENT) {

      // Check for WXR XML marker
      // TODO: document why extra validation can't be performed, THERE IS NO DTD FOR WXR!
      if ($reader->name == 'rss') {
        $is_wxr_file = $reader->moveToAttribute('xmlns:wp');
      }

      if ($reader->name == 'wp:base_blog_url') {
        $reader->read();
        $wordpress_import->data['baseurl'] = $reader->value;
        if (substr($wordpress_import->data['baseurl'], -1) != '/') {
          $wordpress_import->data['baseurl'] .= '/';
        }
      }

      // Read posts data
      if ($reader->name == 'item') {
        $reader->read();
        $wordpress_import->count['posts']++;
      }

      // Read categories data
      if ($reader->name == 'wp:category') {
        $domCategory = $reader->expand();
        $wordpress_import->data['categories'][] = array();
        foreach ($domCategory->childNodes as $node) {
          $wordpress_import->data['categories'][key($wordpress_import->data['categories'])][substr($node->nodeName, 3)] = $node->nodeValue;
        }
        next($wordpress_import->data['categories']);
        $wordpress_import->count['categories']++;
      }

      // Read tags data
      if ($reader->name == 'wp:tag_name') {
        $reader->read();
        $tag_name = $reader->value;
        $wordpress_import->data['tags'][$tag_name] = '';
        while ($reader->read() && !($reader->name == 'wp:tag' && $reader->nodeType == XMLReader::END_ELEMENT)) {
            if ($reader->name == 'wp:tag_description' && $reader->nodeType == XMLReader::ELEMENT) {
                $reader->read();
                $wordpress_import->data['tags'][$tag_name] = $reader->value;
            }
        }
        $wordpress_import->count['tags']++;
      }

      // Read users data, create user map array
      if ($reader->name == 'dc:creator') {
        $reader->read();
        $wordpress_import->usermap[$reader->value] = 0;
        $wordpress_import->count['author_posts'][$reader->value]++;
      }

      // Count comments
      if ($reader->name == 'wp:comment') {
        $wordpress_import->count['comments']++;
      }
    }
    elseif ($reader->name == 'rss' && $reader->nodeType == XMLReader::END_ELEMENT) {
      // Reached the end of the document, we can safely assume valid XML
      $is_valid_xml = TRUE;
    }
  }

  $reader->close();

  return $is_wxr_file && $is_valid_xml;
}

/**
 * Create a Drupal vocabulary and return it's vid.
 */
function wordpress_import_create_vocabulary($type, $vocabulary_data) {

  $vocabulary = FALSE;

  // Check if a category for Wordpress already exists
  $vocabulary_id = variable_get('wordpress_import_'. $type, 0);

  if ($vocabulary_id) {
    $vocabulary = taxonomy_vocabulary_load($vocabulary_id);
  }

  if ($vocabulary) {
    return $vocabulary->vid;
  }
  else {
    taxonomy_save_vocabulary($vocabulary_data);
    variable_set('wordpress_import_'. $type, $vocabulary_data['vid']);
    return $vocabulary_data['vid'];
  }
}

/**
 * Return an array of taxonomy terms belonging to a vocabulary
 */
function wordpress_import_get_terms($vid) {
  $db_result = db_query("SELECT t.tid, t.* FROM {term_data} t WHERE t.vid = %d", $vid);

  $result = array();
  while ($term = db_fetch_object($db_result)) {
    $result[$term->name] = $term->tid;
  }

  return $result;
}

/**
 * cURL helper function since PHP has disabled redirection support.
 * Taken from http://www.php.net/manual/en/function.curl-setopt.php#71313
 */
function curl_redir_url($ch) {
    static $curl_loops = 0;
    static $curl_max_loops = 20;
    if ($curl_loops++ >= $curl_max_loops) {
        $curl_loops = 0;
        return FALSE;
    }
    curl_setopt($ch, CURLOPT_HEADER, TRUE);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
    curl_setopt($ch, CURLOPT_NOBODY, TRUE);
    $header = curl_exec($ch);
    $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);
    if ($http_code == 301 || $http_code == 302) {
        $matches = array();
        preg_match('/Location:(.*?)\n/', $header, $matches);
        $url = @parse_url(trim(array_pop($matches)));
        if (!$url) {
            //couldn't process the url to redirect to
            $curl_loops = 0;
            return FALSE;
        }
        $last_url = parse_url(curl_getinfo($ch, CURLINFO_EFFECTIVE_URL));
        if (!$url['scheme'])
            $url['scheme'] = $last_url['scheme'];
        if (!$url['host'])
            $url['host'] = $last_url['host'];
        if (!$url['path'])
            $url['path'] = $last_url['path'];
        $new_url = $url['scheme'] . '://' . $url['host'] . $url['path'] . ($url['query'] ? '?' . $url['query'] : '');
        curl_setopt($ch, CURLOPT_URL, $new_url);
        //debug('Redirecting to', $new_url);
        return curl_redir_url($ch);
    }
    elseif ($http_code == 200) {
      $curl_loops = 0;
      return curl_getinfo($ch, CURLINFO_EFFECTIVE_URL);
    }
    else {
      $curl_loops = 0;
      return FALSE;
    }
}
